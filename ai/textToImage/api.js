const fs = require('fs');
const https = require('https');
const path = require('path');
const fetch = require('node-fetch');
const { generateAsync } = require('stability-client')
const { generate_texture_by_fragment, directExternalApiCall, getOpenaiClient} = require('../openai/utils')
require('fs');
const { promisify } = require('util');
const pipeline = promisify(require('stream').pipeline);

// Define the API options
const API_TYPES = {
  STABLE_DIFFUSION: {
    url: 'https://openai.com/api/textToImage/stable_diffusion',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': 'Bearer <sk-12DRm1jAa3In5XalwbVahkxBK5VhWzAqKc7KDmBsBodSxCnE>'
    }
  },
  // Add other APIs here as needed...
};

function responseToTextureModels(response) {
  return response.output.map(imageUrl => ({
    status: response.status,
    generationTime: response.generationTime,
    id: response.id,
    imageUrl: imageUrl,
    width: response.meta.W,
    height: response.meta.H,
    prompt: response.meta.prompt,
  }));
}


async function downloadImage(url, path) {
    return new Promise((resolve, reject) => {
        https.get(url, (res) => {
            if (res.statusCode !== 200) {
                reject(new Error(`Request Failed With Status Code: ${res.statusCode}`));
                return;
            }

            const file = fs.createWriteStream(path);
            res.pipe(file);

            file.on('finish', () => {
                resolve();
            });

            file.on('error', (err) => {
                fs.unlink(path, () => {}); // Delete the file async if we have an error
                reject(err);
            });
        }).on('error', (err) => {
            reject(err);
        });
    });
}

async function textToImageOpenAi(prompt, samples=1, localPath, shouldMock= false){
  if(shouldMock)
  {
    return {
      url: `https://oaidalleapiprodscus.blob.core.windows.net/private/org-QEgcgJZRR8O5I4TU81OtIzQr/user-x8YFabEYMtNouC3KDRNrvqNt/img-DyFU8k9br5ifd27AbfL65YlI.png?st=2023-11-23T23%3A06%3A28Z&se=2023-11-24T01%3A06%3A28Z&sp=r&sv=2021-08-06&sr=b&rscd=inline&rsct=image/png&skoid=6aaadede-4fb3-4698-a8f6-684d7786b067&sktid=a48cca56-e6da-484e-a814-9c849652bcb3&skt=2023-11-23T20%3A18%3A16Z&ske=2023-11-24T20%3A18%3A16Z&sks=b&skv=2021-08-06&sig=ePHJceNpabp6Sb8CH5try7uAN3QdzapO6YSAPTkHJ9U%3D`,
      revised_prompt:`Compose a 1024x1024 full-frame Art Nouveau style illustration influenced by the chilling aura of Siberian folklore for the front side of an RPG character creation card named 'A Wisp Lantern' in Noto Sans font. The scene is bathed in a soft, icy blue light showcasing an ethereal lantern that gives an impression of being made from the chill of a mountaintop. The lantern cage resembles crystalline formations of frost and inside, a blue wisp dances like a flickering flame. This creates long, intricâ€¦ld. The scene encapsulates the cold, mysterious aura of a high mountain summit and the secrets of an ancient lighthouse. Remember to use intricate filigree designs inspired by icicles, and flourishes suggesting gusts of wind and snow to embellish the design. This grainy, cinematic, impressionistic artwork should evoke a sense of discovery evocative of a core game book, inviting players to immerse themselves into the character creation process via the selection of this collector's edition card.`
}
  }
  
  else{
    const response = await getOpenaiClient().images.generate(
      { model: "dall-e-3",
        prompt,
        size:"1024x1024",
        n:1,
      }
    )
    const {revised_prompt, url} = response.data[0]
    await downloadImage(url, localPath)
   return {revised_prompt, url, localPath}
  } 
  
}


function characterCreationOptionPrompt(cardStats){
  const {title, font, illustration, description, texture, category, subcategory} = cardStats;
  return `Create a full-frame illustration for the front side of a virtual RPG character creation card. The card, 
  titled '${title}' in ${font} font.(and this is the ONLY readable text in this illustration). the card is in category ${category} and ${subcategory} subcategory. . 
  Please create this front full frame illustration out of this illustration description: 
  "llustration': '${illustration}' and also reference this: "${description}". The design should fill the entire frame. No additional text besides the title.
  the back side of the card is generated by this prompt: "${texture}". 
  I want the front side to have the same artistic influences and theme. the use of embellishments etc.
  Remember, the design should fill the WHOLE frame. it's a full frame illustration!! make it epic.  size 1024X1024. artStation winner. 
  cinematic. inspiring and inviting to discover a hero through the process of choosing cards.`
  
}

async function textToImage(prompt, samples=1, path){
  try {

    if (!fs.existsSync(path)){
      fs.mkdirSync(path);
    }
  
    const { res, images } = await generateAsync({
      prompt: `${prompt}`,
      apiKey: 'sk-12DRm1jAa3In5XalwbVahkxBK5VhWzAqKc7KDmBsBodSxCnE',
      samples: samples,
      engine: 'stable-diffusion-xl-1024-v1-0',
      outDir: path,
      steps: 40,
      width: 1024,
      height: 1024,
      seed: 0,
      samples: 1,
    })
    console.log(images)
    return images.map((img) => {
      return img.filePath.replace(/^.*\/assets/, '/assets');
    });
  
  } catch (e) {
    console.log(e)
  }
};

async function generateTextureImgFromPrompt(prompt, apiKey, apiOptions = {}, samples=4) {
  // Merge with default options
  const options = {
    width: '512',
    height: '512',
    samples,
    num_inference_steps: '20',
    guidance_scale: 7.5,
    safety_checker: 'yes',
    multi_lingual: 'no',
    panorama: 'no',
    self_attention: 'no',
    upscale: 'no',
    
    ...apiOptions,
  };

  const response = await fetch('https://stablediffusionapi.com/api/v3/text2img', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      key: apiKey,
      prompt: prompt,
      ...options,
    }),
  });

  if (!response.ok) {
    throw new Error(`HTTP error ${response.status}`);
  }

  const data = await response.json();
  const textureModels = responseToTextureModels(data);
  await Promise.all(textureModels.map(textureModel => saveTextureModelToDB(textureModel)));
  return textureModels;
}


async function generateTexturesFromPrompts(prompt, sessionId = 100){

  const sanitizeString = (str) => {
    return str.replace(/[^a-zA-Z0-9-_]/g, '_');  // Replace any character that's not a letter, number, underscore, or dash with an underscore
  }
  
  const firstThreeWords = sanitizeString(prompt.split(' ').slice(0, 3).join('_'));
  const subfolderName = `${firstThreeWords}_${sessionId}`;
  const subfolderPath = path.join(__dirname, '../../assets', subfolderName);

  if (!fs.existsSync(subfolderPath)){
    fs.mkdirSync(subfolderPath);
  }

  fs.writeFileSync(path.join(subfolderPath, 'original_prompt.txt'), prompt);
  
  const generateTexturesPrompt = generate_texture_by_fragment(prompt);
  const texturePrompts = await directExternalApiCall(generateTexturesPrompt);
  const textures = await Promise.all(texturePrompts.map(async (texturePrompt, index) => {
    // Create a subfolder for the texture
    texturePrompt.prompt +=  ` archetypal. card Texture. symbolic`
    const textureSubfolderName = `texture_${index}`;
    const textureSubfolderPath = path.join(subfolderPath, textureSubfolderName);
  
    if (!fs.existsSync(textureSubfolderPath)){
      fs.mkdirSync(textureSubfolderPath);
    }

    fs.writeFileSync(path.join(textureSubfolderPath, 'texture_prompt.txt'), texturePrompt.prompt);
    const url = await textToImage(texturePrompt.prompt, 1, textureSubfolderPath);
    return {url, font: texturePrompt.font}
  }));
  
  
  return textures;
}

module.exports = {
  generateTextureImgFromPrompt,
  generateTexturesFromPrompts,
  textToImage,
  textToImageOpenAi,
  characterCreationOptionPrompt
};



